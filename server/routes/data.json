[
  {
    "id": "1000000001",
    "title": "两数之和",
    "journal": "Data structure and algorithm",
    "volume": 43,
    "number": 1,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "给定 nums = [2, 7, 11, 15], target = 9，因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]",
    "link": "",
    "keywords": ["两数之和"],
    "body": "var twoSum = function(nums, target) { \n for (var i = 0; i < nums.length; i++) {\n var dif = target - nums[i];\n // j = i + 1 的目的是减少重复计算和避免两个元素下标相同\n for (var j = i + 1; j < nums.length; j++) {\n if(nums[j] == dif)\n return [i,j];\n }\n }\n };"
  },
  {
    "id": "1000000002",
    "title": "两数相加",
    "journal": "Data structure and algorithm",
    "volume": 54,
    "number": 2,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "输入：(2 -> 4 -> 3) + (5 -> 6 -> 4),输出：7 -> 0 -> 8,原因：342 + 465 = 807",
    "link": "",
    "keywords": ["两数相加"],
    "body": "var addTwoNumbers = function(l1, l2) {\n    let sum     = 0\n    let head    = {}\n    let cur     = head\n\n    while(l1 || l2 || sum) {\n        sum    += (l1 && l1.val) + (l2 && l2.val)\n        cur     = cur.next = new ListNode(sum % 10)\n\n        l1      = l1 && l1.next\n        l2      = l2 && l2.next\n        sum     = Math.floor(sum / 10)\n    }\n    return head.next\n};"
  },
  {
    "id": "1000000003",
    "title": "无重复字符的最长子串",
    "journal": "Data structure and algorithm",
    "volume": 36,
    "number": 3,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n示例 1:\n\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n",
    "link": "",
    "keywords": ["无重复字符的最长子串"],
    "body": "var lengthOfLongestSubstring = function(s) {\n    var res = 0,\n        i = 0;\n    var temp = [];\n    while(i < s.length) {\n        if(temp.indexOf(s[i]) === -1) {\n            temp.push(s[i]);\n        } else {\n            temp.shift();\n            continue;\n        }\n        res = Math.max(res, temp.length);\n        i++;\n    }\n    return res;\n};"
  },
  {
    "id": "1000000004",
    "title": "寻找两个有序数组的中位数",
    "journal": "Data structure and algorithm",
    "volume": 27,
    "number": 4,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\n\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n\n你可以假设 nums1 和 nums2 不会同时为空。\n",
    "link": "",
    "keywords": ["寻找两个有序数组的中位数"],
    "body": "let findMedianSortedArrays = function(nums1, nums2) {\n  let len1 = nums1.length,len2 = nums2.length;\n  let mid = len1 + len2 >> 1; // 中位数位置, 取mid mid+1两个\n  let i = 0,j = 0,cur;\n  let n1,n2;\n  while(i<len1 || j<len2){\n    if(j === len2 || nums1[i] < nums2[j]){\n      cur = nums1[i];\n      i ++;\n    }else{\n      cur = nums2[j];\n      j ++;\n    }\n    if(i + j === mid){\n      n1 = cur\n    }\n    if(i + j === mid + 1) {\n      n2 = cur;\n      break;\n    }\n  }\n  return (len1 + len2) % 2 === 0 ? (n1 + n2)/2 : n2;\n};"
  },
  {
    "id": "1000000005",
    "title": "最长回文子串",
    "journal": "Data structure and algorithm",
    "volume": 55,
    "number": 5,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n示例 1：\n\n输入: \"babad\"\n输出: \"bab\"\n注意: \"aba\" 也是一个有效答案。\n",
    "link": "",
    "keywords": ["最长回文子串"],
    "body": "var longestPalindrome = function(s) {\nvar max = 0;\nvar maxSubString = \"\";\nfor(let i=0; i<s.length; i++){\n    for(let j=i+1; j<s.length+1; j++){\n        if(isPalindrom(s.substring(i,j))){\n            if(j-i > max){  // 有更长的，则更新最长子串\n                max = j-i;\n                maxSubString = s.substring(i,j);\n            }\n\n        }\n    }\n}\nreturn maxSubString;\n};\n\nvar isPalindrom = function(s){\nvar l = s.length;\nvar flag = 0;\nfor (let i=0; i<l/2; i++){\n    if(s[i]!==s[l-1-i]){\n        flag = 1;\n    }\n}\nif(flag === 1){\n    return false;\n}\nreturn true;\n"
  },
  {
    "id": "1000000006",
    "title": "Z 字形变换",
    "journal": "Data structure and algorithm",
    "volume": 48,
    "number": 6,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n\n比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下：\n\nL   C   I   R\nE T O E S I I G\nE   D   H   N\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。\n\n请你实现这个将字符串进行指定行数变换的函数：\n\nstring convert(string s, int numRows);\n",
    "link": "",
    "keywords": ["Z 字形变换"],
    "body": "var convert = function(s, numRows) {\n    if(numRows===0)return ''\n    if(numRows===1)return s\n    var isDown = false\n    var nowRow = 0\n    var array = new Array(numRows).fill('')\n    array.forEach.call(s,val=>{\n        array[nowRow]+=val\n        if(nowRow===numRows-1){\n            isDown = false\n        } else if(nowRow===0){\n            isDown = true\n        }\n        nowRow+=isDown?1:-1\n    })\n    return array.join('')\n};\n"
  },
  {
    "id": "1000000007",
    "title": "整数反转",
    "journal": "Data structure and algorithm",
    "volume": 76,
    "number": 7,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n\n示例 1:\n\n输入: 123\n输出: 321",
    "link": "",
    "keywords": ["整数反转"],
    "body": "var reverse = function(x) {\n    var isPositive = x < 0 ? true : false;\n    var target = ((isPositive ? -x : x).toString().split(\"\").reverse().join(''));\n        target = isPositive ? -target : +target; \n    var outRange = target < Math.pow(-2, 31) ||  target > (Math.pow(2, 31)-1);\n    return outRange ? 0 : target;\n};\nlet x = 120;\nlet result = reverse(x);\nconsole.log(result);\n"
  },
  {
    "id": "1000000008",
    "title": "字符串转换整数 (atoi)",
    "journal": "Data structure and algorithm",
    "volume": 77,
    "number": 8,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。\n\n示例 1:\n\n输入: \"42\"\n输出: 42\n",
    "link": "",
    "keywords": ["字符串转换整数 (atoi)"],
    "body": "const myAtoi = function(str) {\n  // 提取需要的字符\n  const result = str.trim().match(/^(-|\\+)?\\d+/g);\n  return result\n    ? Math.max(Math.min(Number(result[0]), 2 ** 31 - 1), -(2 ** 31))\n    : 0;\n};\n说明：\n\n使用正则提取满足条件的字符，/^(-|\\+)?\\d+/g，(-|\\+)?表示第一位是-或+或都不是，\\d+表示匹配多个数字。\nMath.max(Math.min(Number(result[0]), 2 ** 31 - 1), -(2 ** 31))是- 2 ** 31 < num < 2 ** 31 - 1的js写法，保证不超出范围。\n"
  },
  {
    "id": "1000000009",
    "title": "回文数",
    "journal": "Data structure and algorithm",
    "volume": 87,
    "number": 9,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n示例 1:\n\n输入: 121\n输出: true",
    "link": "",
    "keywords": ["回文数"],
    "body": "var isPalindrome = function(x) {\n    return x == x.toString().split('').reverse().join('') ? true : false\n};\n"
  },
  {
    "id": "1000000010",
    "title": "正则表达式匹配",
    "journal": "Data structure and algorithm",
    "volume": 34,
    "number": 10,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。\n\n'.' 匹配任意单个字符\n'*' 匹配零个或多个前面的那一个元素\n所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。\n\n说明:\n\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。\n",
    "link": "",
    "keywords": ["正则表达式匹配"],
    "body": "function match(s,p){\nlet reg=new RegExp('^'+p+'$')\nreturn reg.test(s)\n}"
  },
  {
    "id": "1000000011",
    "title": "盛最多水的容器",
    "journal": "Data structure and algorithm",
    "volume": 56,
    "number": 11,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n\n说明：你不能倾斜容器，且 n 的值至少为 2。\n",
    "link": "",
    "keywords": ["盛最多水的容器"],
    "body": "var maxArea = function(height) {\n    //brute force\n    let maxArea = Number.MIN_SAFE_INTEGER\n    let left = 0;\n    let right = height.length - 1;\n    while( left < right){\n        maxArea = Math.max(maxArea, (right-left) * Math.min(height[left],height[right]));\n        if(height[left] >= height[right]){\n            right --\n        }else{\n            left ++\n        }\n    }\n    return maxArea\n};\n"
  },
  {
    "id": "1000000012",
    "title": "整数转罗马数字",
    "journal": "Data structure and algorithm",
    "volume": 67,
    "number": 12,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\n\n示例 1:\n\n输入: 3\n输出: \"III\"\n",
    "link": "",
    "keywords": ["整数转罗马数字"],
    "body": "var intToRoman = function(num) {\n    function TurnFive(n, one, five, ten){\n        if(n != 0){\n            if(n < 4){\n                return one.repeat(n);\n            }\n            if(n == 4){\n                return one + five;\n            }\n            if(n < 9){\n                let times = n-5;\n                let I = one.repeat(times)\n                return five + I;\n            }\n            if(n == 9){\n                return one + ten;\n            }            \n        }\n        return \"\";\n    }\n    let than = Math.floor(num / 1000);\n    let hon = Math.floor(num % 1000 / 100);\n    let ten = Math.floor(num % 1000 % 100 /10);\n    let ge = Math.floor(num % 1000 %100 % 10);\n    return TurnFive(than, \"M\", \"\", \"\") + \n            TurnFive(hon, \"C\", \"D\", \"M\") + \n            TurnFive(ten, \"X\", \"L\", \"C\") + \n            TurnFive(ge, \"I\", \"V\", \"X\");\n};\n"
  },
  {
    "id": "1000000013",
    "title": "罗马数字转整数",
    "journal": "Data structure and algorithm",
    "volume": 55,
    "number": 13,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n示例 1:\n\n输入: \"III\"\n输出: 3\n",
    "link": "",
    "keywords": ["罗马数字转整数"],
    "body": "var romanToInt = function(s) {\n    var obj = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    };\n    \n    if (s.length == 0) return 0;\n    if (s.length == 1) return obj[s];\n    \n    var result = 0;\n    for (var i=0; i<s.length; i++) {\n        if(obj[s[i]] < obj[s[i+1]]) {\n            result += obj[s[i+1]] - obj[s[i]]\n            i++\n        } else {\n            result += obj[s[i]]\n        }\n    }\n    return result;\n};\n"
  },
  {
    "id": "1000000014",
    "title": "最长公共前缀",
    "journal": "Data structure and algorithm",
    "volume": 32,
    "number": 14,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 \"\"。\n\n示例 1:\n\n输入: [\"flower\",\"flow\",\"flight\"]\n输出: \"fl\"\n",
    "link": "",
    "keywords": ["最长公共前缀"],
    "body": "var longestCommonPrefix = function(strs) {\n    strs.sort()//按编码排序\n    if (strs.length === 0) return ''//空数组返回''\n    var first = strs[0],\n        end = strs[strs.length - 1]\n    if(first === end || end.match(eval('/^' + first + '/'))){\n        return first//first包含于end返回first\n    }\n    for(var i=0;i<first.length;i++){\n        if(first[i] !== end[i]){\n            return first.substring(0,i)//匹配失败时返回相应字符串\n        }\n    }\n};\n"
  },
  {
    "id": "1000000015",
    "title": "三数之和",
    "journal": "Data structure and algorithm",
    "volume": 15,
    "number": 6,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。\n\n \n\n示例：\n\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n",
    "link": "",
    "keywords": ["三数之和"],
    "body": "var threeSum = function (nums) {\n  nums.sort((a, b) => { return a - b })\n  // 先排序，才能左右夹逼\n  let res = []\n  for (k = 0; k < nums.length; k++) {\n    if (nums[k] > 0) break\n    // 如果当前数大于 0，不用循环，因为 k 是最小数，最小数已经大于 0，三数之和不可能等于 0\n    if (k > 0 && nums[k] === nums[k - 1]) continue\n    // 去重\n    let i = k + 1\n    let j = nums.length - 1\n\n    while (i < j) {\n      // 夹逼条件，如果两个边界都挨着了就不用循环了\n      let sum = nums[k] + nums[i] + nums[j]\n      if (sum === 0) {\n        // 满足条件 push 到返回数组\n        res.push([nums[k], nums[i], nums[j]])\n        while (nums[i] === nums[++i]) { }\n        while (nums[j] === nums[--j]) { }\n        // 去重，相当于下面四句，去重后还要指向不重复的那一个\n        // while (nums[i] === nums[i + 1]) { i++ }\n        // while (nums[j] === nums[j - 1]) { j-- }\n        // i++\n        // j--\n      } else if (sum < 0) {\n        // 小于 0 说明左边界的数小了，往右移动，因为整个数是排序好的\n        // k > i + j，i 右移动，可以让 i + j 更大一点\n        // \n        i++\n      } else {\n        // 左夹\n        j--\n      }\n    }\n  }\n  return res\n};\n"
  },
  {
    "id": "1000000016",
    "title": "最接近的三数之和",
    "journal": "Data structure and algorithm",
    "volume": 45,
    "number": 16,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\n\n例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.\n\n与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).\n",
    "link": "",
    "keywords": ["最接近的三数之和"],
    "body": "var threeSumClosest = function (nums, target) {\n    const len = nums.length;\n    if (len < 3) {\n        return null;\n    }\n    nums.sort((a, b) => a - b);\n    // 结果，比存储 sum 方便，下面对比时不用再用 target - sum 对比\n    let res = target - (nums[0] + nums[1] + nums[2]);\n    for (let i = 0; i < len - 2; i++) {\n        // 左指针为 i+1，右指针为 nums.length - 1\n        let left = i + 1,\n            right = len - 1;\n\n        while (left < right) {\n            const sum = nums[i] + nums[left] + nums[right];\n            if (sum === target) {\n                return sum;\n            } else if (sum < target) {\n                // sum < target 时，left++\n                while (nums[left] === nums[++left]);\n            } else {\n                // sum > target时，right--\n                while (nums[right] === nums[--right]);\n            }\n            // 存储与 target 最近的值\n            if (Math.abs(sum - target) < Math.abs(res)) {\n                res = target - sum;\n            }\n        }\n    }\n    return target - res;\n};\n"
  },
  {
    "id": "1000000017",
    "title": "电话号码的字母组合",
    "journal": "Data structure and algorithm",
    "volume": 67,
    "number":17,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n示例:\n\n输入：\"23\"\n输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].",
    "link": "",
    "keywords": ["电话号码的字母组合"],
    "body": "function getCombination(digits) {\n  const reg = /[2-9]{1,}/g;\n  if (!reg.test(digits)) {\n    return [];\n  }\n  const table = new Map();\n  table.set(\"2\", [\"a\", \"b\", \"c\"]);\n  table.set(\"3\", [\"d\", \"e\", \"f\"]);\n  table.set(\"4\", [\"g\", \"h\", \"i\"]);\n  table.set(\"5\", [\"j\", \"k\", \"l\"]);\n  table.set(\"6\", [\"m\", \"n\", \"o\"]);\n  table.set(\"7\", [\"p\", \"q\", \"r\", \"s\"]);\n  table.set(\"8\", [\"t\", \"u\", \"v\"]);\n  table.set(\"9\", [\"w\", \"x\", \"y\", \"z\"]);\n\n  let first = table.get(digits[0]);\n  if (digits.length === 1) {\n    return first;\n  }\n\n  const combinate = (subDigits, preArr) => {\n    const num = subDigits[0];\n    const second = table.get(num);\n    let result = preArr.reduce((accumulator, currentValue) => {\n      second.forEach(ele => {\n        accumulator.push(`${currentValue}${ele}`);\n      });\n      return accumulator;\n    }, []);\n\n    if (subDigits.length === 1) {\n      return result || [];\n    } else {\n      return combinate(subDigits.substring(1), result);\n    }\n  };\n\n  return combinate(digits.substring(1), first);\n}\n"
  },
  {
    "id": "1000000018",
    "title": "四数之和",
    "journal": "Data structure and algorithm",
    "volume": 89,
    "number": 18,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。\n\n注意：\n\n答案中不可以包含重复的四元组。\n\n示例：\n\n给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。\n\n满足要求的四元组集合为：\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n",
    "link": "",
    "keywords": ["四数之和"],
    "body": "var fourSum = function (nums, target) {\n    if (nums.length < 4) {\n        return [];\n    }\n    nums.sort((a, b) => a - b);\n    const result = [];\n    for (let i = 0; i < nums.length - 3; i++) {\n        // 若与已遍历过的数字相同，避免结果中出现重复的数组\n        if (i > 0 && nums[i] === nums[i - 1]) {\n            continue;\n        }\n        // 若当前循环的前四位数字已大于 target\n        if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {\n            break;\n        }\n        for (let j = i + 1; j < nums.length - 2; j++) {\n            // 若与已遍历过的数字相同，避免结果中出现重复的数组\n            if (j > i + 1 && nums[j] === nums[j - 1]) {\n                continue;\n            }\n            let left = j + 1,\n                right = nums.length - 1;\n            while (left < right) {\n                const sum = nums[i] + nums[j] + nums[left] + nums[right];\n                if (sum === target) {\n                    result.push([nums[i], nums[j], nums[left], nums[right]]);\n                }\n                if (sum <= target) {\n                    while (nums[left] === nums[++left]);\n                } else {\n                    while (nums[right] === nums[--right]);\n                }\n            }\n        }\n    }\n    return result;\n};\n"
  },
  {
    "id": "1000000019",
    "title": "有效的括号",
    "journal": "Data structure and algorithm",
    "volume": 98,
    "number": 19,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n注意空字符串可被认为是有效字符串。\n\n示例 1:\n\n输入: \"()\"\n输出: true\n",
    "link": "",
    "keywords": ["有效的括号"],
    "body": "var isValid = function (s) {\n  let len = s.length;\n  let first = s[0];\n  if (len === 0) return true;\n  // 奇数或右括号开头肯定不符合\n  if (len % 2 != 0 || [')', ']', '}'].indexOf(first) != -1) {\n    return false\n  }\n  // 栈，存入第一个字符。\n  let stack = [first];\n  const MAP = {\n    ')': '(',\n    ']': '[',\n    '}': '{',\n  }\n  for (let i = 1; i < len; i++) {\n    let length = stack.length;\n    let top = length > 0 ? stack[length - 1] : null;\n    let now = s[i];\n    if (MAP[now] === top) {\n      stack.pop();\n    } else {\n      stack.push(now);\n    }\n  }\n  return stack.length === 0\n};\n"
  },
  {
    "id": "1000000020",
    "title": "删除链表的倒数第N个节点",
    "journal": "Data structure and algorithm",
    "volume": 49,
    "number":20,
    "pages": "",
    "year": 2020,
    "authors": [],
    "abstract": "给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n\n示例：\n\n给定一个链表: 1->2->3->4->5, 和 n = 2.\n\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n说明：\n\n给定的 n 保证是有效的。\n",
    "link": "",
    "keywords": ["删除链表的倒数第N个节点"],
    "body": "var removeNthFromEnd = function(head, n) {\n    let left = head;\n    let right = head;\n    let i = 0;\n\n    while (i++ < n) {\n        right = right.next;\n    }\n\n    if (!right) {\n        return head.next;\n    }\n\n    while (right.next) {\n        left = left.next;\n        right = right.next;\n    }\n\n    const oldNext = left.next;\n    left.next = left.next.next;\n    oldNext.next = null;\n    return head;\n};\n"
  }
]
